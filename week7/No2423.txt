1).해당 문제 해결 기법을 사용한 근거 (논리적인 근거)
① 문제인식
첫째 줄에 N
둘째 줄에 주사위에 쓰여 있는 수
위의 그림에서 A, B, C, D, E, F에 쓰여 있는 수가 차례대로 주어진다

② 문제 유형 파악:
N × M 직사각형 크기의 전자 회로를 디자인
회로에는 N × M개의 정사각형 타일이 있고, 모두 직사각형의 변과 평행하다. 
모든 타일은 두 개의 마주보는 꼭짓점이 전선으로 연결되어 있다.
전원은 왼쪽 위 모서리에 연결되어 있고, 전구는 오른쪽 아래 모서리에 연결되어 있다. 

몇개의 타일을 90도 회전 가능할 떄,
전구에 불을 켜기 위해 돌려야 하는 칸의 개수의 최솟값을 구하는 프로그램을 작성하시오.

=> 다익스트라, 다이내믹 프로그래밍

2). 의사 코드 또는 DFA 다이어그램 작성 (대략적으로 작성)
➀  	 int[][] move1 = {{-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; // 대각선
	 int[][] move2 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 상하좌우
	 int N, M; 
	 char[][] arr; 입력받은 전선 저장
	 int[][] visit; 다녀간 전선 + 방향을 바꾼 전선의 개수


➁ int cnt = arr[N - 1][M - 1] == '\\' ? 0 : 1;
		cnt += arr[0][0] == '\\' ? 0 : 1;
		arr[N - 1][M - 1] = '\\'; 
        
        => arr[0][0] arr[N - 1][M - 1]의 전선의 모양은 무조건 \ 여야만 하기에 주어진 값에 따라 cnt 더해주기

➂ 1) 대각선으로 이동하는 경우
    for(int i=0; i<4; i++) { // 대각선으로 이동하는 경우, 현재 타일과 같아야 연결 가능
                    if((now.wire == '\\' && (i == 1 || i == 2)) 
                            || (now.wire == '/' && (i == 0 || i == 3)))
                        continue;
    }

 2) 상하좌우로 이동하는 경우 
    for(int i=0;i<4;i++) { // 상하좌우로 이동하는 경우, 현재 타일과 달라야 연결 가능
        int nextR = now.r + move2[i][0];
        int nextC = now.c + move2[i][1];
    }
    => 연결되어있을 경우 cnt ++ 아닐 시 그대로 현재노드 갱신

