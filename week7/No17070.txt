1).해당 문제 해결 기법을 사용한 근거 (논리적인 근거)
① 문제인식
첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)
둘째 줄부터 N개의 줄에는 집의 상태
빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.
 
② 문제 유형 파악:
새 집의 크기는 N×N의 격자판 (1×1크기의 정사각형 칸) => 각각의 칸은 (r, c)

집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 2개의 연속된 칸을 차지하는 크기이다.
파이프는 회전이 가능하다
파이프는 항상 빈 칸만 차지해야 한다.

파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향
회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.

가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.

=> 다이내믹 프로그래밍

2). 의사 코드 또는 DFA 다이어그램 작성 (대략적으로 작성)
➀ map = new int[n][n]; 집 모양
  dp = new int[n][n][3]; 지금까지 와 온 루트
    0: 가로, 1: 대각선, 2: 세로 => 기존 파이프의 모양에 따라 갈 수 있는 루트가 다르기 때문에 저장

➁  for (int i = 0; i < n; i++) 
    for (int j = 2; j < n; j++) =>파이프를 놓을 수 있는 것은 2열부터

➂ continue 경우
1. map[i][j] == 1 : 길이 막혀있음
2. i == 0 : 맨 윗줄
3. map[i - 1][j] == 1 || map[i][j - 1] == 1 : 왼쪽 위쪽이 막혀있으면

루트 더하는 경우
1. dp[i][j][0] = dp[i][j - 1][0] + dp[i][j - 1][1] : 가로방향
2. dp[i][j][2] = dp[i - 1][j][1] + dp[i - 1][j][2] : 세로방향
3. dp[i][j][1] = dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2] : 대각선 방향

=> return dp[n - 1][n - 1][0] + dp[n - 1][n - 1][1] + dp[n - 1][n - 1][2] : 모두 
